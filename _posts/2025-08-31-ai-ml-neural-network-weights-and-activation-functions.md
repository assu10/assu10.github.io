---
layout: post
title:  "AI - 인공 신경망 신호 전달 원리(가중치, 편향, 활성화 함수)"
date: 2025-08-31
categories: dev
tags: ai ml machine-learning deep-learning neural-network activation-function weights bias sigmoid relu softmax normalization
---

인공 신경망은 우리 뇌의 동작 방식, 특히 뉴런의 정보 처리 과정에서 영감을 얻어 탄생했다.  
인공 신경망의 학습 원리를 깊이 이해하기 위해서는, 먼저 그 기반이 된 뇌의 어떤 특징을 모방했는지 살펴볼 필요가 있다.

뇌 속의 뉴런들은 서로 전기 신호를 주고 받으며 복잡한 네트워크를 형성한다. 하나의 뉴런이 다음 뉴런으로 신호를 전달하는 이 간단한 과정이 모여 우리의 사고, 판단, 
그리고 신체 움직임과 가은 고차원적인 활동을 가능하게 한다.

인공 신경망 역시 이와 유사한 구조를 가진다.

이번 포스트에서는 뇌 속 뉴런의 신호 전달 메커니즘을 통해 인공 신경망의 핵심적인 두 가지 특징을 살펴본다.  
바로 **신호를 전달하는 과정**과 **전달받은 신호를 처리하는 과정**이다.  
이 두 가지 과정을 이해한다면 인공 신경망의 기본 동작 원리를 명확하게 파악할 수 있다.

---

**목차**

<!-- TOC -->
* [1. 신호를 전달할 때 사용하는 가중치(weight)와 편향(bias)](#1-신호를-전달할-때-사용하는-가중치weight와-편향bias)
* [2. 들어오는 신호 세기를 조절하는 활성화 함수 (Activation Function)](#2-들어오는-신호-세기를-조절하는-활성화-함수-activation-function)
  * [2.1. 시그모이드(Sigmoid) 함수](#21-시그모이드sigmoid-함수)
  * [2.2. 하이퍼볼릭탄젠트(Hyperbolic Tangent, tanh) 함수](#22-하이퍼볼릭탄젠트hyperbolic-tangent-tanh-함수)
  * [2.3. 렐루(ReLU Function, Rectified Linear Unit) 함수](#23-렐루relu-function-rectified-linear-unit-함수)
  * [2.4. 소프트맥스(Softmax) 함수](#24-소프트맥스softmax-함수)
* [참고 사이트 & 함께 보면 좋은 사이트](#참고-사이트--함께-보면-좋은-사이트)
<!-- TOC -->

---

# 1. 신호를 전달할 때 사용하는 가중치(weight)와 편향(bias)

인공 신경망이 뇌의 뉴런이 신호를 주고받는 모습과 유사하다고 설명했다. 하지만 인공 신경망의 뉴런은 단순히 신호를 전달만 하는 것이 아니라, 입력받은 신호의 **'중요도'**와 **'기존 활성 수준'**을 
조절하여 다음 뉴런으로 전달한다. 이때 사용되는 핵심 개념이 바로 **가중치**와 **편향**이다.

![가중치와 편향에 따라 달라지는 신호 세기](/assets/img/dev/2025/0831/weight.png)

---

**가중치(Weight): 신호이 중요도를 결정하는 값**

여러 개의 이전 뉴런에서 신호를 받을 때, 각 신호가 다음 뉴런에게 미치는 영향력은 저마다 다를 수 있다.  
가중치는 바로 이 **신호의 중요도 또는 영향력을 조절하는 값**이다.

뉴런과 뉴런을 연결하는 선(synapse)에는 각각의 가중치가 존재한다.
- **가중치가 크다**는 것은 해당 입력 신호가 결과에 **중요한 영향을 미친다**는 의미임
- 반대로 **가중치가 작다**는 것은 신호의 **영향력이 상대적으로 적다**는 의미임
- **가중치가 음수(-)**를 가질 수도 있는데, 이는 해당 신호가 다음 뉴런의 활성을 **억제하는 방향**으로 작용함을 의미함

---

**편향(Bias): 뉴런의 활성화를 조절하는 값**

편향은 가중치를 거쳐 변환된 신호가 얼마나 쉽게 활성화될지를 조절하는 역할을 한다. 모든 입력 신호에 가중치가 곱해진 값들의 합에 편향이 더해진다.

즉, 편향은 뉴런이 **얼마나 쉽게 '흥분'하는지를 결정하는 기준점**이라고 생각할 수 있다. 편향 값이 높을수록 뉴런은 작은 신호에도 쉽게 활성화되고, 편향 값이 낮을수록 
더 큰 신호가 들어와야만 활성화된다.

> 편향은 한쪽으로 치우친다는 것을 의미한다. 인공 신경망에서는 모델 성능을 높이기 위해 가중치를 거쳐 변환된 신호 세기를 조절할 필요가 있다.  
> 이를 위해 한쪽으로 치우치는 값을 더할 때 편향이라는 값을 사용한다.

- 가중치는 **'모든 연결선'**마다 하나씩 존재
- 편향은 (은닉층과 출력층의) **'각 뉴런'**마다 하나씩 존재 (입력층 제외)

---

**인공 신경망의 학습이란?**

결국 **인공 신경망이 학습**한다는 것은 주어진 데이터에 대해 최적의 예측을 할 수 있도록 **수많은 연결선에 있는 가중치와 각 뉴런의 편향을 정교하게 조정해나가는 과정**이다.  
잘 학습된 모델은 데이터의 패턴을 정확하게 표현하는 가중치와 편향 값을 가지고 있다.

---

# 2. 들어오는 신호 세기를 조절하는 활성화 함수 (Activation Function)

뉴런이 가중치와 편향을 통해 입력 신호의 중요도를 결정한다고 했다.  
이제 뉴런은 조절된 신호들의 총합을 받은 후, 이 정보를 다음 뉴런으로 **'전달할지 말지'**, 그리고 **'어떤 세기로 전달할지'** 결정해야 한다. 
이 중요한 결정을 내리는 역할이 바로 활성화 함수**(Activation Function)**의 몫이다.

다음 뉴런으로 정보를 전달할지 말지 결정할 때 사용되는 개념이 바로 **역치(Threshold)**이다.  
뇌의 뉴런은 특정 값(역치) 이상의 전기 신호가 들어와야만 다음 뉴런으로 신호를 전달하고, 그 값보다 작으면 신호를 무시한다.  
즉, 모든 신호에 반응하는 것이 아니라 의미 있는 신호만을 선별적으로 전달하는 것이다.

인공 신경망의 활성화 함수는 바로 이 '역치' 메커니즘을 수학적으로 구현한 것이다.  
각 뉴런에 들어온 신호들의 총합(가중합)을 그대로 흘려보내는 것이 아니라 활성화 함수라는 '필터'를 거쳐 출력값을 변환하고 조절한다.

![활성화 함수](/assets/img/dev/2025/0831/activation.png)

**활성화 함수의 핵심 역할**  
하나의 뉴런으로 모인 여러 입력 신호들을 종합하여, 정해진 규칙에 따라 하나의 값으로 벼환하고 신호의 세기를 결정하는 것이다.  
이 과정을 통해 신경망은 단순한 선형 결합을 넘어선 복잡한 패턴을 학습할 수 있는 **비선형성(non-linearity)**를 갖추게 된다.

이제, 가장 대표적인 활성화 함수들을 하나씩 살펴본다.

---

## 2.1. 시그모이드(Sigmoid) 함수

**시그모이드 함수**는 인공 신경망 초기에 널리 사용된 활성화 함수이다. 부드러운 **S자 형태의 곡선**을 그리는 것이 특징이다.

이 함수의 기원은 생태학에서 특정 환경 내 개체 수의 증가를 모델링하기 위해 사용하던 **로지스틱 함수(Logistic Function)**이다.

![로지스틱 함수](/assets/img/dev/2025/0831/logistic.png)

예를 들어, 메뚜기 개체 수는 무한정 증가하는 것이 아니라, 처음에는 서서히 증가하다가 폭발적으로 늘어나고, 먹이나 공간의 한계로 인해 결국 증가세가 둔화하며 특정 
수준에 수렴한다.

시그모이드 함수는 이러한 S자 성장 곡선과 형태가 같다.

시그모이드 함수는 입력받은 값을 **0과 1사이의 값**으로 변환하여 출력한다.

![시그모이드 함수](/assets/img/dev/2025/0831/sigmoid.png)

- 입력값이 매우 큰 양수이면 출력값은 **1**에 가까워진다.(활성화 상태)
- 입력값이 매우 작은 음수이면 출력값은 **0**에 가까워진다.(비활성화 상태)
- 입력값이 0이면 정확히 **0.5**를 출력한다.

이러한 특징 때문에 시그모이드 함수는 어떤 결과가 나올 확률을 예측하는 [이진 분류(Binary Classification)](https://assu10.github.io/dev/2025/08/15/ai-ml-learning-methods-guide/#21-%EC%A7%80%EB%8F%84-%ED%95%99%EC%8A%B5supervised-learning-%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%A9%B0-%EA%B0%80%EB%A5%B4%EC%B9%98%EA%B8%B0) 문제의 출력층에서 특히 유용하게 사용된다.

하지만 신경망의 깊이가 깊어질수록 기울기 소실(Vanishing Gradient) 문제가 발생할 수 있어, 최근에는 은닉층에서는 사용 빈도가 줄어드는 추세이다.

---

## 2.2. 하이퍼볼릭탄젠트(Hyperbolic Tangent, tanh) 함수

하이퍼볼릭탄젠트 함수는 시그모이드 함수를 개선한 버전이라고 볼 수 있다. 두 함수는 S자 곡선을 그린다는 점에서 매우 유사하지만, 결정적인 차이점이 있다.

![하이퍼볼릭탄젠트 함수와 시그모이드 함수](/assets/img/dev/2025/0831/hyper.png)

바로 **출력값의 범위**이다.
- **시그모이드 함수**: 출력값이 **0과 1사이**에 분포(중심점: 0.5)
- **하이퍼볼릭탄젠트 함수**: 출력값이 **-1과 1사이**에 분포(중심점: 0)

하이퍼볼릭탄젠트 함수의 가장 큰 장점은 출력값의 중심이 0이라는 **'Zero-Centered'** 특징이다. 출력값이 0을 기준으로 양수와 음수로 고르게 분포하면, 
신경망의 학습 과정에서 편향되지 않은 신호를 다음 레이어로 전달할 수 있어 학습 효율이 더 높아지는 경향이 있다.

시그모이드 함수는 입력값이 음수일 때 항상 0에 가까운 값을 출력하여 기울기 소실 문제를 유발하는 원인이 되기도 했다.  
반면, 하이퍼볼릭탄젠트 함수는 음수 입력에 대해 -1에 가까운 음수 값을 출력하므로, 신호의 '억제'를 더 명확하게 표현할 수 있어 시그모이느 함수보다 더 선호되는 경우가 많다.

> 하이퍼볼릭은 쌍곡선이라는 의미로, 쌍곡선은 두 지점에서 거리가 같은 곡선을 의미한다.  
> 하이퍼볼릭탄젠트 함수 그래프를 보면 대칭이 되는 특정한 두 점에서 거리가 항상 같은 것을 확인할 수 있다.

---

## 2.3. 렐루(ReLU Function, Rectified Linear Unit) 함수

렐루 함수는 현재 **딥러닝 모델에서 가장 표준적으로 사용되는 활성화 함수**라고 할 수 있다. 그 이유는 놀라울 정도로 간단한 구조에 강력한 성능이 나오기 때문이다.

![시그모이드 함수](/assets/img/dev/2025/0831/sigmoid.png)
![하이퍼볼릭탄젠트 함수](/assets/img/dev/2025/0831/hyper2.png)
![렐루 함수](/assets/img/dev/2025/0831/relu.png)

렐루 함수의 규칙은 매우 직관적이다.
- 입력(x)이 0보다 크면: **입력값을 그대로 출력**(x=y)
- 입력(x)이 0보다 작거나 같으면: **0을 출력**(y=0) 

ReLU 는 아래와 같은 장점이 있다.
- **빠른 계산 속도**
  - 단순한 조건문으로 구현되어 시그모이드나 하이퍼볼릭탄젠트 함수보다 연산 속도가 매우 빠름
- **기울기 소실 문제 해결**
  - 양수 입력에 대해 기울기가 항상 1이므로, 신경망이 깊어져도 기울기가 사라지지 않고 잘 전달됨
  - 이는 심층 신경망(Deep Neural Network)의 학습을 가능하게 한 핵심 요인임

하지만 렐루 함수에도 단점은 존재한다. 입력값이 음수이면 항상 0을 출력하기 때문에, 해당 뉴런이 더 이상 학습 과정에 참여하지 못하는 **'죽은 렐루(Dying Relu)'** 현상이 발생할 수 있다.

이러한 단점을 보완하기 위해 Leaky Relu 라는 함수가 등장했다.

![Leaky 렐루 함수](/assets/img/dev/2025/0831/leaky.png)

Leaky ReLU 는 음수 입력에 대해 0을 출력하는 대신, 아주 작은 기울기(예: 0.01)를 가진 선형 함수를 사용한다.  
즉, 음수 신호라도 완전히 무시하지 않고 아주 약간의 정보는 다음으로 전달하는 것이다.  
이 작은 변화만으로도 '죽은 렐루' 현상을 방지하고 학습 안정성을 높이는 데 큰 도움이 된다.

---

## 2.4. 소프트맥스(Softmax) 함수

소프트맥스 함수는 활성화 함수는 아니다. 은닉층이 아닌, 주로 **출력층에서 사용되는 함수**이기 때문이다.

신경망이 여러 개 중 하나를 고르는 [분류 문제](https://assu10.github.io/dev/2025/08/15/ai-ml-learning-methods-guide/#21-%EC%A7%80%EB%8F%84-%ED%95%99%EC%8A%B5supervised-learning-%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%A9%B0-%EA%B0%80%EB%A5%B4%EC%B9%98%EA%B8%B0)를 푼다고 가정해보자.  
예를 들어, 이미지를 보고 '개', '고양이', '새' 중 하나로 판단하는 모델의 출력층에는 각 클래스에 해당하는 3개의 뉴런이 있을 것이다. 마지막 계산을 마친 후 
뉴런이 아래와 같은 최종 점수를 받았다고 해보자.

- 개: 2.9
- 고양이: 1.3
- 새: 0.2

가장 점수가 높은 '개'가 정답일 확률이 높아 보이지만, 이 점수만으로는 "모델이 '개'라고 얼마나 확신하는지" 직관적으로 알기 어렵다.

**소프트맥스는 바로 이 최종 점수들을 '확률'로 변환해주는 역할**을 한다. 위 점수들에 소프트맥스 함수를 적용하면 아래와 같다.
- 개: 0.8(80%)
- 고양이: 0.15(15%)
- 새: 0.05(5%)

소프트맥스의 핵심 기능은 출력층의 각 뉴런이 출력하는 결과값(Score)을 **정규화(Normalization)**하여, **모든 출력값의 총합이 1이 되는 확률 분포**로 만들어준다.  
이를 통해 각 클래스가 정답일 확률이 몇 %인지 명확하게 해석할 수 있다.

> 정규화는 특정한 범위를 지정하고, 데이터를 그 범위 중 하나로 바꾸어주는 것임  
> 가장 작은 데이터를 0으로, 가장 큰 데이터를 1로 바꾸고 그 사이의 값에 따라 0과 1사이의 값으로 바꿈

이처럼 소프트맥스 함수는 신경망의 최종 예측 결과를 가장 해석하기 쉬운 '확률'의 형태로 만들어주기 때문에, 이진 분류 및 다중 분류 문제의 출력층에서 필수적으로 사용되는 매우 중요한 함수이다.

---

# 참고 사이트 & 함께 보면 좋은 사이트

*본 포스트는 이영호 저자의 **모두의 인공지능 with 파이썬**을 기반으로 스터디하며 정리한 내용들입니다.*

* [모두의 인공지능 with 파이썬](https://product.kyobobook.co.kr/detail/S000217061005)